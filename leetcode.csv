15,3sum,3Sum,"<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>

<p>Notice that the solution set must not contain duplicate triplets.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,0,1,2,-1,-4]
<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]
<strong>Explanation:</strong> 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,1]
<strong>Output:</strong> []
<strong>Explanation:</strong> The only possible triplet does not sum up to 0.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,0]
<strong>Output:</strong> [[0,0,0]]
<strong>Explanation:</strong> The only possible triplet sums up to 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
",Medium,"func threeSum(nums []int) [][]int {
    
}","
class Solution:
    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:
        # two pointer solution
        # sort the array first
        # for each element, find the other two elements that sum to 0
        # if the sum is less than 0, move the left pointer
        # if the sum is greater than 0, move the right pointer
        # 
        # Time complexity: O(n^2)
        # Space complexity: O(1)

        nums.sort()
        res = []
        for i in range(len(nums)-2):
            j, k = i+1, len(nums)-1
            if i &gt; 0 and nums[i] == nums[i-1]:
                continue
            while j &lt; k:
                if nums[j] + nums[k] == -nums[i]:
                    res.append(tuple([nums[j], nums[k], nums[i]]))
                    j += 1
                    k -= 1
                elif nums[j] + nums[k] &lt; -nums[i]:
                    j += 1
                else:
                    k -= 1
        return list(set(res))

",array two-pointers sorting
2,add-two-numbers,Add Two Numbers,"<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum&nbsp;as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg"" style=""width: 483px; height: 342px;"" />
<pre>
<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]
<strong>Output:</strong> [7,0,8]
<strong>Explanation:</strong> 342 + 465 = 807.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> l1 = [0], l2 = [0]
<strong>Output:</strong> [0]
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
<strong>Output:</strong> [8,9,9,9,0,0,0,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 9</code></li>
	<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>
</ul>
",Medium,"/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    
}","
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:
        dummy = ListNode(0)
        result = dummy
        carry = 0
        while l1 or l2:
            l1val = l1.val if l1 else 0
            l2val = l2.val if l2 else 0
            result.next = ListNode((l1val+l2val+carry)%10)
            carry = 1 if l1val + l2val + carry &gt;= 10 else 0
            result = result.next
            l1 = l1.next if l1 else l1
            l2 = l2.next if l2 else l2
        if carry:
            result.next = ListNode(carry)
        return dummy.next

",linked-list math recursion
894,all-possible-full-binary-trees,All Possible Full Binary Trees,"<p>Given an integer <code>n</code>, return <em>a list of all possible <strong>full binary trees</strong> with</em> <code>n</code> <em>nodes</em>. Each node of each tree in the answer must have <code>Node.val == 0</code>.</p>

<p>Each element of the answer is the root node of one possible tree. You may return the final list of trees in <strong>any order</strong>.</p>

<p>A <strong>full binary tree</strong> is a binary tree where each node has exactly <code>0</code> or <code>2</code> children.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png"" style=""width: 700px; height: 400px;"" />
<pre>
<strong>Input:</strong> n = 7
<strong>Output:</strong> [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> [[0,0,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
",Medium,"/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func allPossibleFBT(n int) []*TreeNode {
    
}","
class Solution:
    def allPossibleFBT(self, n: int) -&gt; List[TreeNode]:
        if n % 2 == 0:
            return []
        if n == 1:
            return [TreeNode()]

        res = []
        for i in range(1, n, 2):
            left = self.allPossibleFBT(i)
            right = self.allPossibleFBT(n - i - 1)

            for l in left:
                for r in right:
                    root = TreeNode(0, l, r)
                    res.append(root)

        return res
",dynamic-programming tree recursion memoization binary-tree
735,asteroid-collision,Asteroid Collision,"<p>We are given an array <code>asteroids</code> of integers representing asteroids in a row.</p>

<p>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</p>

<p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> asteroids = [5,10,-5]
<strong>Output:</strong> [5,10]
<strong>Explanation:</strong> The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> asteroids = [8,-8]
<strong>Output:</strong> []
<strong>Explanation:</strong> The 8 and -8 collide exploding each other.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> asteroids = [10,2,-5]
<strong>Output:</strong> [10]
<strong>Explanation:</strong> The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= asteroids.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li>
	<li><code>asteroids[i] != 0</code></li>
</ul>
",Medium,"func asteroidCollision(asteroids []int) []int {
    
}","
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -&gt; List[int]:
        stack = []

        for ast in asteroids:
            if not stack or stack[-1] &lt; 0 or ast &gt; 0:
                stack.append(ast)
                continue
            while stack and stack[-1] &gt; 0:
                if abs(stack[-1]) == abs(ast):
                    stack.pop()
                    break
                elif abs(stack[-1] &lt; abs(ast)):
                    stack.pop()
                    if not stack or stack[-1] &lt; 0:
                        stack.append(ast)
                        break
                elif abs(stack[-1] &gt; abs(ast)):
                    break
                
                    
        return stack
                
                





        
",array stack simulation
309,best-time-to-buy-and-sell-stock-with-cooldown,Best Time to Buy and Sell Stock with Cooldown,"<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>

<p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:</p>

<ul>
	<li>After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</li>
</ul>

<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> prices = [1,2,3,0,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> transactions = [buy, sell, cooldown, buy, sell]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> prices = [1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= prices.length &lt;= 5000</code></li>
	<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
",Medium,"func maxProfit(prices []int) int {
    
}","
class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        memo = {}
        def act(i, buy):
            if i &gt;= len(prices):
                return 0
            if (i, buy) in memo:
                return memo[(i, buy)]
            if buy:
                memo[(i, buy)] = max(act(i+1, False)-prices[i], act(i+1, True))
            else:
                memo[(i, buy)] = max(act(i+2, True)+prices[i], act(i+1, False))
            return memo[(i, buy)]
        
        res = act(0, True)
        return res
                     
",array dynamic-programming
121,best-time-to-buy-and-sell-stock,Best Time to Buy and Sell Stock,"<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>

<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>

<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> prices = [7,1,5,3,6,4]
<strong>Output:</strong> 5
<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> prices = [7,6,4,3,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> In this case, no transactions are done and the max profit = 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>
</ul>
",Easy,"func maxProfit(prices []int) int {
    
}","
class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        mini = prices[0]
        result = 0
        for p in prices[1:]:
            mini = min(mini, p)
            result = max(result, p-mini)
        return result
        
",array dynamic-programming
704,binary-search,Binary Search,"<p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>

<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 9
<strong>Output:</strong> 4
<strong>Explanation:</strong> 9 exists in nums and its index is 4
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong> 2 does not exist in nums so return -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt; nums[i], target &lt; 10<sup>4</sup></code></li>
	<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>
	<li><code>nums</code> is sorted in ascending order.</li>
</ul>
",Easy,"func search(nums []int, target int) int {
    
}","
class Solution:
    def search(self, nums: List[int], target: int) -&gt; int:
        l, r = 0, len(nums)-1

        while l &lt;= r:
            mid = l + (r-l) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] &lt; target:
                l = mid + 1
            else:
                r = mid - 1
        return -1
",array binary-search
199,binary-tree-right-side-view,Binary Tree Right Side View,"<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/14/tree.jpg"" style=""width: 401px; height: 301px;"" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,5,null,4]
<strong>Output:</strong> [1,3,4]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1,null,3]
<strong>Output:</strong> [1,3]
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
",Medium,"/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) []int {
    
}","
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:
        if not root:
            return []
        q = collections.deque()
        q.append(root)
        res = []
        while q:
            size = len(q)
            last = None
            for _ in range(size):
                cur = q.popleft()
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
                last = cur.val
            res.append(last)
        return res


",tree depth-first-search breadth-first-search binary-tree
103,binary-tree-zigzag-level-order-traversal,Binary Tree Zigzag Level Order Traversal,"<p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes&#39; values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg"" style=""width: 277px; height: 302px;"" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[3],[20,9],[15,7]]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
",Medium,"/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func zigzagLevelOrder(root *TreeNode) [][]int {
    
}","
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:
        q = collections.deque()
        if root:
            q.append(root)
        result = []
        flag = True
        while q:
            l = len(q)
            temp = []
            for _ in range(l):
                cur = q.popleft()
                temp.append(cur.val)
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            if flag:
                result.append(temp)
            else:
                result.append(reversed(temp))
            flag = not flag
        return result


            


",tree breadth-first-search binary-tree
853,car-fleet,Car Fleet,"<p>There are <code>n</code> cars going to the same destination along a one-lane road. The destination is <code>target</code> miles away.</p>

<p>You are given two integer array <code>position</code> and <code>speed</code>, both of length <code>n</code>, where <code>position[i]</code> is the position of the <code>i<sup>th</sup></code> car and <code>speed[i]</code> is the speed of the <code>i<sup>th</sup></code> car (in miles per hour).</p>

<p>A car can never pass another car ahead of it, but it can catch up to it&nbsp;and drive bumper to bumper <strong>at the same speed</strong>. The faster car will <strong>slow down</strong> to match the slower car&#39;s speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).</p>

<p>A <strong>car fleet</strong> is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.</p>

<p>If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.</p>

<p>Return <em>the <strong>number of car fleets</strong> that will arrive at the destination</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.
The car starting at 0 does not catch up to any other car, so it is a fleet by itself.
The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.
Note that no other cars meet these fleets before the destination, so the answer is 3.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> target = 10, position = [3], speed = [3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is only one car, hence there is only one fleet.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> target = 100, position = [0,2,4], speed = [4,2,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.
Then, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == position.length == speed.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt; target &lt;= 10<sup>6</sup></code></li>
	<li><code>0 &lt;= position[i] &lt; target</code></li>
	<li>All the values of <code>position</code> are <strong>unique</strong>.</li>
	<li><code>0 &lt; speed[i] &lt;= 10<sup>6</sup></code></li>
</ul>
",Medium,"func carFleet(target int, position []int, speed []int) int {
    
}","
class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -&gt; int:
        cars = [(a, b) for a, b in zip(position, speed)]
        cars.sort(reverse=True)
        stack = []
        stack.append(cars[0])
        for p, v in cars[1:]:
            if (target-p)/v &lt;= (target-stack[-1][0])/stack[-1][1]:
                continue
            stack.append((p,v))
        return len(stack)
                
        

",array stack sorting monotonic-stack
70,climbing-stairs,Climbing Stairs,"<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>

<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
",Easy,"func climbStairs(n int) int {
    
}","
class Solution:
    def climbStairs(self, n: int) -&gt; int:
        one = 1
        two = 1
        i = 0
        while i &lt; n:
            one, two = two + one, one
            i+=1
        return two
",math dynamic-programming memoization
518,coin-change-ii,Coin Change II,"<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>

<p>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.</p>

<p>You may assume that you have an infinite number of each kind of coin.</p>

<p>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> amount = 5, coins = [1,2,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> amount = 3, coins = [2]
<strong>Output:</strong> 0
<strong>Explanation:</strong> the amount of 3 cannot be made up just with coins of 2.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> amount = 10, coins = [10]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= coins.length &lt;= 300</code></li>
	<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>
	<li>All the values of <code>coins</code> are <strong>unique</strong>.</li>
	<li><code>0 &lt;= amount &lt;= 5000</code></li>
</ul>
",Medium,"func change(amount int, coins []int) int {
    
}","
class Solution:
    def change(self, amount: int, coins: List[int]) -&gt; int:
        
        @cache
        def go(cur, i):
            if cur &gt; amount or i &gt;= len(coins):
                return 0
            if cur == amount:
                return 1
            sumi = 0
            sumi+=go(cur+coins[i], i)
            sumi+=go(cur, i+1)
            return sumi
        
        return go(0, 0)

",array dynamic-programming
322,coin-change,Coin Change,"<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>

<p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>

<p>You may assume that you have an infinite number of each kind of coin.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> coins = [1,2,5], amount = 11
<strong>Output:</strong> 3
<strong>Explanation:</strong> 11 = 5 + 5 + 1
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> coins = [2], amount = 3
<strong>Output:</strong> -1
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> coins = [1], amount = 0
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= coins.length &lt;= 12</code></li>
	<li><code>1 &lt;= coins[i] &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>0 &lt;= amount &lt;= 10<sup>4</sup></code></li>
</ul>
",Medium,"func coinChange(coins []int, amount int) int {
    
}","
class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:

        dp = [0] * (amount+1)

        for i in range(1, amount+1):
            mini = float(&#39;inf&#39;)
            for j in range(len(coins)):
                if i - coins[j] &gt;= 0:
                    mini = min(mini, 1+dp[i - coins[j]])
            dp[i] = mini
        
        return dp[-1] if dp[-1] != float(&#39;inf&#39;) else -1



",array dynamic-programming breadth-first-search
39,combination-sum,Combination Sum,"<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of </em><code>candidates</code><em> where the chosen numbers sum to </em><code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>

<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the <span data-keyword=""frequency-array"">frequency</span> of at least one of the chosen numbers is different.</p>

<p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> candidates = [2,3,6,7], target = 7
<strong>Output:</strong> [[2,2,3],[7]]
<strong>Explanation:</strong>
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> candidates = [2,3,5], target = 8
<strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> candidates = [2], target = 1
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
	<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>
	<li>All elements of <code>candidates</code> are <strong>distinct</strong>.</li>
	<li><code>1 &lt;= target &lt;= 40</code></li>
</ul>
",Medium,"func combinationSum(candidates []int, target int) [][]int {
    
}","
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        res = []
        def go(sofar, sumi, i):
            if sumi &gt; target:
                return
            if sumi == target:
                res.append(sofar)
                return
            if i &gt;= len(candidates):
                return
            go(sofar+[candidates[i]], sumi+candidates[i], i)
            go(sofar, sumi, i+1)
            return
        go([], 0, 0)
        return res

",array backtracking
11,container-with-most-water,Container With Most Water,"<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i<sup>th</sup></code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>

<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>

<p>Return <em>the maximum amount of water a container can store</em>.</p>

<p><strong>Notice</strong> that you may not slant the container.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"" style=""width: 600px; height: 287px;"" />
<pre>
<strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]
<strong>Output:</strong> 49
<strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> height = [1,1]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == height.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>
</ul>
",Medium,"func maxArea(height []int) int {
    
}","
class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        l, r = 0, len(height) - 1
        maxi = 0
        while l &lt; r:
            maxi = max((r-l)*min(height[l], height[r]), maxi)
            if height[l] &lt; height[r]:
                l += 1
            else:
                r -= 1
        return maxi

        
",array two-pointers greedy
138,copy-list-with-random-pointer,Copy List with Random Pointer,"<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>

<p>Construct a <a href=""https://en.wikipedia.org/wiki/Object_copying#Deep_copy"" target=""_blank""><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>

<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>

<p>Return <em>the head of the copied linked list</em>.</p>

<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>

<ul>
	<li><code>val</code>: an integer representing <code>Node.val</code></li>
	<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>
</ul>

<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2019/12/18/e1.png"" style=""width: 700px; height: 142px;"" />
<pre>
<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2019/12/18/e2.png"" style=""width: 700px; height: 114px;"" />
<pre>
<strong>Input:</strong> head = [[1,1],[2,1]]
<strong>Output:</strong> [[1,1],[2,1]]
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<p><strong><img alt="""" src=""https://assets.leetcode.com/uploads/2019/12/18/e3.png"" style=""width: 700px; height: 122px;"" /></strong></p>

<pre>
<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]
<strong>Output:</strong> [[3,null],[3,0],[3,null]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 1000</code></li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>
</ul>
",Medium,"/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Next *Node
 *     Random *Node
 * }
 */

func copyRandomList(head *Node) *Node {
    
}","
&#34;&#34;&#34;
class Node:
    def __init__(self, x: int, next: &#39;Node&#39; = None, random: &#39;Node&#39; = None):
        self.val = int(x)
        self.next = next
        self.random = random
&#34;&#34;&#34;

class Solution:
    def copyRandomList(self, head: &#39;Optional[Node]&#39;) -&gt; &#39;Optional[Node]&#39;:
        if not head:
            return head
        m = {head: Node(head.val)}
        dummy = head

        while head and head.next:
            if head.next and head.next not in m:
                m[head.next] = Node(head.next.val)
            if head.random and head.random not in m:
                m[head.random] = Node(head.random.val)
            m[head].next = m[head.next] if head.next else None
            m[head].random = m[head.random] if head.random else None
            head = head.next
        m[head].random = m[head.random] if head and head.random else None
        return m[dummy]


",hash-table linked-list
207,course-schedule,Course Schedule,"<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>

<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>
	<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>
</ul>
",Medium,"func canFinish(numCourses int, prerequisites [][]int) bool {
    
}","
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        adj_list = collections.defaultdict(list)

        for c, p in prerequisites:
            adj_list[c].append(p)

        visited = set()
        def take(course, so_far):
            so_far.add(course)
            visited.add(course)
            res = True
            for p in adj_list[course]:
                if p in so_far:
                    return False
                if p not in visited:
                    res = res and take(p, so_far)
            so_far.remove(course)
            return res
        for i in range(numCourses):
            if i not in visited and not take(i, set()):
                return False
        return True

                    
                



            
",depth-first-search breadth-first-search graph topological-sort
944,delete-columns-to-make-sorted,Delete Columns to Make Sorted,"<p>You are given an array of <code>n</code> strings <code>strs</code>, all of the same length.</p>

<p>The strings can be arranged such that there is one on each line, making a grid.</p>

<ul>
	<li>For example, <code>strs = [&quot;abc&quot;, &quot;bce&quot;, &quot;cae&quot;]</code> can be arranged as follows:</li>
</ul>

<pre>
abc
bce
cae
</pre>

<p>You want to <strong>delete</strong> the columns that are <strong>not sorted lexicographically</strong>. In the above example (<strong>0-indexed</strong>), columns 0 (<code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>) and 2 (<code>&#39;c&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;e&#39;</code>) are sorted, while column 1 (<code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>, <code>&#39;a&#39;</code>) is not, so you would delete column 1.</p>

<p>Return <em>the number of columns that you will delete</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;cba&quot;,&quot;daf&quot;,&quot;ghi&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The grid looks as follows:
  cba
  daf
  ghi
Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;a&quot;,&quot;b&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The grid looks as follows:
  a
  b
Column 0 is the only column and is sorted, so you will not delete any columns.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The grid looks as follows:
  zyx
  wvu
  tsr
All 3 columns are not sorted, so you will delete all 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == strs.length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= strs[i].length &lt;= 1000</code></li>
	<li><code>strs[i]</code> consists of lowercase English letters.</li>
</ul>
",Easy,"func minDeletionSize(strs []string) int {
    
}","
class Solution:
    def minDeletionSize(self, strs: List[str]) -&gt; int:
        count = 0
        for i in range(len(strs[0])):
            for j in range(1, len(strs)):
                if ord(strs[j][i]) &lt; ord(strs[j-1][i]):
                    count += 1
                    break
        return count

",array string
2816,double-a-number-represented-as-a-linked-list,Double a Number Represented as a Linked List,"<p>You are given the <code>head</code> of a <strong>non-empty</strong> linked list representing a non-negative integer without leading zeroes.</p>

<p>Return <em>the </em><code>head</code><em> of the linked list after <strong>doubling</strong> it</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/05/28/example.png"" style=""width: 401px; height: 81px;"" />
<pre>
<strong>Input:</strong> head = [1,8,9]
<strong>Output:</strong> [3,7,8]
<strong>Explanation:</strong> The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/05/28/example2.png"" style=""width: 401px; height: 81px;"" />
<pre>
<strong>Input:</strong> head = [9,9,9]
<strong>Output:</strong> [1,9,9,8]
<strong>Explanation:</strong> The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>4</sup>]</code></li>
	<li><font face=""monospace""><code>0 &lt;= Node.val &lt;= 9</code></font></li>
	<li>The input is generated such that the list represents a number that does not have leading zeros, except the number <code>0</code> itself.</li>
</ul>
",Medium,"/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func doubleIt(head *ListNode) *ListNode {
    
}","
class Solution:
    def doubleIt(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        result = ListNode(0)
        dummy = result
        carry = 0
        def reverse(cur, prev):
            if not cur:
                return prev
            nxt = cur.next
            cur.next = prev
            return reverse(nxt, cur)
        head = reverse(head, None)
        
        while head:
            new_val = (head.val * 2+carry) %10
            carry = (head.val * 2+carry) //10
            dummy.next = ListNode(new_val)
            dummy = dummy.next
            head = head.next
        if carry:
            dummy.next = ListNode(1)
            dummy = dummy.next
        res = reverse(result.next, None)
        return res
            
            
        
        
",linked-list math stack
271,encode-and-decode-strings,Encode and Decode Strings,,Medium,,"
class Codec:
    def encode(self, strs: List[str]) -&gt; str:
        &#34;&#34;&#34;Encodes a list of strings to a single string.
        &#34;&#34;&#34;
        payload = [&#34;,&#34;.join([str(ord(c)) for c in s]) for s in strs]
        return &#34;.&#34;.join(payload)
         

    def decode(self, s: str) -&gt; List[str]:
        &#34;&#34;&#34;Decodes a single string to a list of strings.
        &#34;&#34;&#34;
        payload = s.split(&#39;.&#39;)
        print(payload)
        res = [&#34;&#34;.join([chr(int(c)) if c else &#34;&#34; for c in s.split(&#39;,&#39;)]) for s in payload]
        return res
        
        


",array string design
150,evaluate-reverse-polish-notation,Evaluate Reverse Polish Notation,"<p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a <a href=""http://en.wikipedia.org/wiki/Reverse_Polish_notation"" target=""_blank"">Reverse Polish Notation</a>.</p>

<p>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</p>

<p><strong>Note</strong> that:</p>

<ul>
	<li>The valid operators are <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, and <code>&#39;/&#39;</code>.</li>
	<li>Each operand may be an integer or another expression.</li>
	<li>The division between two integers always <strong>truncates toward zero</strong>.</li>
	<li>There will not be any division by zero.</li>
	<li>The input represents a valid arithmetic expression in a reverse polish notation.</li>
	<li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]
<strong>Output:</strong> 9
<strong>Explanation:</strong> ((2 + 1) * 3) = 9
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]
<strong>Output:</strong> 6
<strong>Explanation:</strong> (4 + (13 / 5)) = 6
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]
<strong>Output:</strong> 22
<strong>Explanation:</strong> ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>
	<li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li>
</ul>
",Medium,"func evalRPN(tokens []string) int {
    
}","
class Solution:
    def evalRPN(self, tokens: List[str]) -&gt; int:
        op = {
            &#34;+&#34;: lambda x, y: x + y,
            &#34;-&#34;: lambda x, y: x - y,
            &#34;*&#34;: lambda x, y: x * y,
            &#34;/&#34;: lambda x, y: int(x / y),
        }
        
        stack = []

        for t in tokens:
            if t in op:
                n2 = stack.pop()
                n1 = stack.pop()
                stack.append(op[t](n1, n2))
            else:
                stack.append(int(t))
        return stack[0]

",array math stack
2810,faulty-keyboard,Faulty Keyboard,"<p>Your laptop keyboard is faulty, and whenever you type a character <code>&#39;i&#39;</code> on it, it reverses the string that you have written. Typing other characters works as expected.</p>

<p>You are given a <strong>0-indexed</strong> string <code>s</code>, and you type each character of <code>s</code> using your faulty keyboard.</p>

<p>Return <em>the final string that will be present on your laptop screen.</em></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;string&quot;
<strong>Output:</strong> &quot;rtsng&quot;
<strong>Explanation:</strong> 
After typing first character, the text on the screen is &quot;s&quot;.
After the second character, the text is &quot;st&quot;. 
After the third character, the text is &quot;str&quot;.
Since the fourth character is an &#39;i&#39;, the text gets reversed and becomes &quot;rts&quot;.
After the fifth character, the text is &quot;rtsn&quot;. 
After the sixth character, the text is &quot;rtsng&quot;. 
Therefore, we return &quot;rtsng&quot;.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;poiinter&quot;
<strong>Output:</strong> &quot;ponter&quot;
<strong>Explanation:</strong> 
After the first character, the text on the screen is &quot;p&quot;.
After the second character, the text is &quot;po&quot;. 
Since the third character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;op&quot;. 
Since the fourth character you type is an &#39;i&#39;, the text gets reversed and becomes &quot;po&quot;.
After the fifth character, the text is &quot;pon&quot;.
After the sixth character, the text is &quot;pont&quot;. 
After the seventh character, the text is &quot;ponte&quot;. 
After the eighth character, the text is &quot;ponter&quot;. 
Therefore, we return &quot;ponter&quot;.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
	<li><code>s[0] != &#39;i&#39;</code></li>
</ul>
",Easy,"func finalString(s string) string {
    
}","
class Solution:
    def finalString(self, s: str) -&gt; str:
        prev = &#34;&#34;
        for c in s:
            if c == &#39;i&#39;:
                prev = &#34;&#34;.join(reversed(prev))
            else:
                prev = prev + c
        return prev
                
        
            
                
        
",string simulation
153,find-minimum-in-rotated-sorted-array,Find Minimum in Rotated Sorted Array,"<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>

<ul>
	<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>
	<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>
</ul>

<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>

<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>

<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time.</code></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,5,1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,6,7,0,1,2]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [11,13,15,17]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 5000</code></li>
	<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
	<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>
	<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>
</ul>
",Medium,"func findMin(nums []int) int {
    
}","
class Solution:
    def findMin(self, nums: List[int]) -&gt; int:

        l, r = 0, len(nums) -1

        while l &lt;= r:
            mid = l + (r-l) // 2
            if nums[mid] &gt; nums[-1]:
                l = mid + 1
            else:
                r = mid - 1
        return nums[l]


",array binary-search
2812,find-the-safest-path-in-a-grid,Find the Safest Path in a Grid,"<p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>n x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A cell containing a thief if <code>grid[r][c] = 1</code></li>
	<li>An empty cell if <code>grid[r][c] = 0</code></li>
</ul>

<p>You are initially positioned at cell <code>(0, 0)</code>. In one move, you can move to any adjacent cell in the grid, including cells containing thieves.</p>

<p>The <strong>safeness factor</strong> of a path on the grid is defined as the <strong>minimum</strong> manhattan distance from any cell in the path to any thief in the grid.</p>

<p>Return <em>the <strong>maximum safeness factor</strong> of all paths leading to cell </em><code>(n - 1, n - 1)</code><em>.</em></p>

<p>An <strong>adjacent</strong> cell of cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> and <code>(r - 1, c)</code> if it exists.</p>

<p>The <strong>Manhattan distance</strong> between two cells <code>(a, b)</code> and <code>(x, y)</code> is equal to <code>|a - x| + |b - y|</code>, where <code>|val|</code> denotes the absolute value of val.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/07/02/example1.png"" style=""width: 362px; height: 242px;"" />
<pre>
<strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/07/02/example2.png"" style=""width: 362px; height: 242px;"" />
<pre>
<strong>Input:</strong> grid = [[0,0,1],[0,0,0],[0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p><strong class=""example"">Example 3:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2023/07/02/example3.png"" style=""width: 362px; height: 242px;"" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.
- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length == n &lt;= 400</code></li>
	<li><code>grid[i].length == n</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is at least one thief in the <code>grid</code>.</li>
</ul>
",Medium,"func maximumSafenessFactor(grid [][]int) int {
    
}","
class Solution:
    def maximumSafenessFactor(self, grid: List[List[int]]) -&gt; int:

        dist = [[float(&#39;inf&#39;)]*len(grid[0]) for _ in range(len(grid))]

        q = collections.deque()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    q.append((i, j, 0))
                    dist[i][j] = 0
        while q:
            i, j, d = q.popleft()
            for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:
                ni, nj = i+di, j+dj
                if 0 &lt;= ni &lt; len(grid) and 0 &lt;= nj &lt; len(grid[0]) and dist[ni][nj] &gt; dist[i][j] + 1:
                    dist[ni][nj] = dist[i][j] + 1
                    q.append((ni, nj, dist[ni][nj]))
        def good(target):
            q = deque()
            visited = [[0]*len(grid[0]) for _ in range(len(grid))]
            if dist[0][0] &gt;= target:
                q.append((0,0))
                visited[0][0] = 1
            while q:
                i, j = q.popleft()
                if (i,j) == (len(grid)-1,len(grid[0])-1):
                    return True
                for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:
                    ni, nj = i+di, j+dj
                    if 0 &lt;= ni &lt; len(grid) and 0 &lt;= nj &lt; len(grid[0]) and not visited[ni][nj] and dist[ni][nj] &gt;= target:
                        visited[ni][nj] = 1
                        q.append((ni, nj))
            return False

        l, r = 0, len(grid)
        while l &lt;= r:
            mid = l + (r-l)//2
            if good(mid):
                l = mid + 1
            else:
                r = mid - 1
        return r
",array binary-search breadth-first-search union-find matrix
134,gas-station,Gas Station,"<p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>i<sup>th</sup></code> station is <code>gas[i]</code>.</p>

<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>i<sup>th</sup></code> station to its next <code>(i + 1)<sup>th</sup></code> station. You begin the journey with an empty tank at one of the gas stations.</p>

<p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> gas = [2,3,4], cost = [3,4,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong>
You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.
Let&#39;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can&#39;t travel around the circuit once no matter where you start.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == gas.length == cost.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li>
</ul>
",Medium,"func canCompleteCircuit(gas []int, cost []int) int {
    
}","
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:
        roll, result = 0, 0
        sumi = 0
        for i, (a, b) in enumerate(zip(gas, cost)):
            if roll &lt; 0:
                roll = 0
                result = i
            roll += a - b
            sumi += a - b
        return result if sumi &gt;= 0 else -1

",array greedy
22,generate-parentheses,Generate Parentheses,"<p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<pre><strong>Input:</strong> n = 3
<strong>Output:</strong> [""((()))"",""(()())"",""(())()"",""()(())"",""()()()""]
</pre><p><strong class=""example"">Example 2:</strong></p>
<pre><strong>Input:</strong> n = 1
<strong>Output:</strong> [""()""]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
",Medium,"func generateParenthesis(n int) []string {
    
}","
class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        result = []

        def generate(sofar, num_open, remain):
            if remain == 0 and num_open == 0:
                result.append(sofar)
                return
            if remain &lt; 0:
                return
            if num_open &gt; 0:
                generate(sofar+&#39;)&#39;, num_open-1, remain)
            generate(sofar+&#39;(&#39;, num_open+1, remain-1)
            return
        generate(&#34;&#34;, 0, n)
        return result
            
            

",string dynamic-programming backtracking
49,group-anagrams,Group Anagrams,"<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>

<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<pre><strong>Input:</strong> strs = [""eat"",""tea"",""tan"",""ate"",""nat"",""bat""]
<strong>Output:</strong> [[""bat""],[""nat"",""tan""],[""ate"",""eat"",""tea""]]
</pre><p><strong class=""example"">Example 2:</strong></p>
<pre><strong>Input:</strong> strs = [""""]
<strong>Output:</strong> [[""""]]
</pre><p><strong class=""example"">Example 3:</strong></p>
<pre><strong>Input:</strong> strs = [""a""]
<strong>Output:</strong> [[""a""]]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
	<li><code>strs[i]</code> consists of lowercase English letters.</li>
</ul>
",Medium,"func groupAnagrams(strs []string) [][]string {
    
}","
class Solution:
    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:
        m = collections.defaultdict(list)
        for str in strs:
            m[tuple(sorted(str))].append(str)
        return m.values()
        
",array hash-table string sorting
274,h-index,H-Index,"<p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>i<sup>th</sup></code> paper, return <em>the researcher&#39;s h-index</em>.</p>

<p>According to the <a href=""https://en.wikipedia.org/wiki/H-index"" target=""_blank"">definition of h-index on Wikipedia</a>: The h-index is defined as the maximum value of <code>h</code> such that the given researcher has published at least <code>h</code> papers that have each been cited at least <code>h</code> times.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> citations = [3,0,6,1,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> citations = [1,3,1]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == citations.length</code></li>
	<li><code>1 &lt;= n &lt;= 5000</code></li>
	<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>
</ul>
",Medium,"func hIndex(citations []int) int {
    
}","
class Solution:
    def hIndex(self, citations: List[int]) -&gt; int:
        citations.sort(reverse=True)
        h = 0
        while h &lt; len(citations):
            if h + 1 &gt; citations[h]:
                break
            h += 1
        return h
",array sorting counting-sort
202,happy-number,Happy Number,"<p>Write an algorithm to determine if a number <code>n</code> is happy.</p>

<p>A <strong>happy number</strong> is a number defined by the following process:</p>

<ul>
	<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
	<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>
	<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>
</ul>

<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 19
<strong>Output:</strong> true
<strong>Explanation:</strong>
1<sup>2</sup> + 9<sup>2</sup> = 82
8<sup>2</sup> + 2<sup>2</sup> = 68
6<sup>2</sup> + 8<sup>2</sup> = 100
1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
",Easy,"func isHappy(n int) bool {
    
}","
class Solution:
    def isHappy(self, n: int) -&gt; bool:
        seen = set()
        while n != 1:
            sumi = 0
            for c in str(n):
                sumi += int(c)*int(c)
            n = sumi
            if n in seen:
                return False
            seen.add(n)
        return True
            
                
            
        
",hash-table math two-pointers
198,house-robber,House Robber,"<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>

<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <b>without alerting the police</b></em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,7,9,3,1]
<strong>Output:</strong> 12
<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
",Medium,"func rob(nums []int) int {
    
}","
class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        
        @cache
        def rob(i):
            if i &gt;=len(nums):
                return 0
            
            return max(nums[i] + rob(i+2), rob(i+1))
        
        return rob(0)
",array dynamic-programming
57,insert-interval,Insert Interval,"<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>

<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>

<p>Return <code>intervals</code><em> after the insertion</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]
<strong>Output:</strong> [[1,5],[6,9]]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
<strong>Output:</strong> [[1,2],[3,10],[12,16]]
<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>
	<li><code>intervals[i].length == 2</code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>
	<li><code>newInterval.length == 2</code></li>
	<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>
</ul>
",Medium,"func insert(intervals [][]int, newInterval []int) [][]int {
    
}","
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:
        result = []
        for i in range(len(intervals)):
            start = intervals[i][0]
            end = intervals[i][1]
            if end &lt; newInterval[0]:
                result.append([start, end])
            elif start &gt; newInterval[1]:
                result.append(newInterval)
                result += intervals[i:]
                return result
            else:
                newInterval[0] = min(newInterval[0], start)
                newInterval[1] = max(newInterval[1], end)
        result.append(newInterval)
        return result 

",array
97,interleaving-string,Interleaving String,"<p>Given strings <code>s1</code>, <code>s2</code>, and <code>s3</code>, find whether <code>s3</code> is formed by an <strong>interleaving</strong> of <code>s1</code> and <code>s2</code>.</p>

<p>An <strong>interleaving</strong> of two strings <code>s</code> and <code>t</code> is a configuration where <code>s</code> and <code>t</code> are divided into <code>n</code> and <code>m</code> <span data-keyword=""substring-nonempty"">substrings</span> respectively, such that:</p>

<ul>
	<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>
	<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>
	<li><code>|n - m| &lt;= 1</code></li>
	<li>The <strong>interleaving</strong> is <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> or <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>
</ul>

<p><strong>Note:</strong> <code>a + b</code> is the concatenation of strings <code>a</code> and <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg"" style=""width: 561px; height: 203px;"" />
<pre>
<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> One way to obtain s3 is:
Split s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.
Interleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.
Since s3 can be obtained by interleaving s1 and s2, we return true.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> Notice how it is impossible to interleave s2 with any other string to obtain s3.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;
<strong>Output:</strong> true
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>
	<li><code>0 &lt;= s3.length &lt;= 200</code></li>
	<li><code>s1</code>, <code>s2</code>, and <code>s3</code> consist of lowercase English letters.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you solve it using only <code>O(s2.length)</code> additional memory space?</p>
",Medium,"func isInterleave(s1 string, s2 string, s3 string) bool {
    
}","
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -&gt; bool:
        @cache
        def go(i, j):
            print(i, j)
            if i == len(s1) and j == len(s2) and i+j == len(s3):
                return True
            if i + j &gt;= len(s3):
                return False
            res = False
            if i &lt; len(s1) and s1[i] == s3[i+j]:
                res = res or go(i+1, j)
            if j &lt; len(s2) and s2[j] == s3[i+j]:
                res = res or go(i, j+1)            
            return res
        
        return go(0, 0)



",string dynamic-programming
226,invert-binary-tree,Invert Binary Tree,"<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg"" style=""width: 500px; height: 165px;"" />
<pre>
<strong>Input:</strong> root = [4,2,7,1,3,6,9]
<strong>Output:</strong> [4,7,2,9,6,3,1]
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg"" style=""width: 500px; height: 120px;"" />
<pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,3,1]
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
",Easy,"/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
    
}","
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:
        if not root:
            return
        root.right, root.left = self.invertTree(root.left), self.invertTree(root.right)
        return root

        
",tree depth-first-search breadth-first-search binary-tree
205,isomorphic-strings,Isomorphic Strings,"<p>Given two strings <code>s</code> and <code>t</code>, <em>determine if they are isomorphic</em>.</p>

<p>Two strings <code>s</code> and <code>t</code> are isomorphic if the characters in <code>s</code> can be replaced to get <code>t</code>.</p>

<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<pre><strong>Input:</strong> s = ""egg"", t = ""add""
<strong>Output:</strong> true
</pre><p><strong class=""example"">Example 2:</strong></p>
<pre><strong>Input:</strong> s = ""foo"", t = ""bar""
<strong>Output:</strong> false
</pre><p><strong class=""example"">Example 3:</strong></p>
<pre><strong>Input:</strong> s = ""paper"", t = ""title""
<strong>Output:</strong> true
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>t.length == s.length</code></li>
	<li><code>s</code> and <code>t</code> consist of any valid ascii character.</li>
</ul>
",Easy,"func isIsomorphic(s string, t string) bool {
    
}","
class Solution:
    def isIsomorphic(self, s: str, t: str) -&gt; bool:
        m = {}
        m2 = {}
        for c1, c2 in zip(s, t):
            if c2 in m and m[c2] != c1:
                return False
            if c1 in m2 and m2[c1] != c2:
                return False
            m[c2] = c1
            m2[c1] = c2
                
        return True
            
",hash-table string
45,jump-game-ii,Jump Game II,"<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at <code>nums[0]</code>.</p>

<p>Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at <code>nums[i]</code>, you can jump to any <code>nums[i + j]</code> where:</p>

<ul>
	<li><code>0 &lt;= j &lt;= nums[i]</code> and</li>
	<li><code>i + j &lt; n</code></li>
</ul>

<p>Return <em>the minimum number of jumps to reach </em><code>nums[n - 1]</code>. The test cases are generated such that you can reach <code>nums[n - 1]</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,1,1,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,0,1,4]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
	<li>It&#39;s guaranteed that you can reach <code>nums[n - 1]</code>.</li>
</ul>
",Medium,"func jump(nums []int) int {
    
}","
class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        dp = [10**5]*len(nums)
        def go(index):
            if index &gt;= len(nums) - 1:
                return 0
            if dp[index] != 10**5:
                return dp[index]
            for i in range(1, nums[index]+1):
                dp[index] = min(dp[index], 1+go(index+i))
            return dp[index]
        return go(0)
",array dynamic-programming greedy
703,kth-largest-element-in-a-stream,Kth Largest Element in a Stream,"<p>Design a class to find the <code>k<sup>th</sup></code> largest element in a stream. Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p>

<p>Implement <code>KthLargest</code> class:</p>

<ul>
	<li><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer <code>k</code> and the stream of integers <code>nums</code>.</li>
	<li><code>int add(int val)</code> Appends the integer <code>val</code> to the stream and returns the element representing the <code>k<sup>th</sup></code> largest element in the stream.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
<strong>Output</strong>
[null, 4, 5, 5, 8, 8]

<strong>Explanation</strong>
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= val &lt;= 10<sup>4</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>.</li>
	<li>It is guaranteed that there will be at least <code>k</code> elements in the array when you search for the <code>k<sup>th</sup></code> element.</li>
</ul>
",Easy,"type KthLargest struct {
    
}


func Constructor(k int, nums []int) KthLargest {
    
}


func (this *KthLargest) Add(val int) int {
    
}


/**
 * Your KthLargest object will be instantiated and called as such:
 * obj := Constructor(k, nums);
 * param_1 := obj.Add(val);
 */","
import heapq
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.size = k
        self.heap = []
        for n in nums:
            heapq.heappush(self.heap, n)
            if len(self.heap) &gt; k:
                heapq.heappop(self.heap)
        

    def add(self, val: int) -&gt; int:
        heapq.heappush(self.heap, val)
        if len(self.heap) &gt; self.size:
            heapq.heappop(self.heap)
        return self.heap[0]

        
        


",tree design binary-search-tree heap-priority-queue binary-tree data-stream
215,kth-largest-element-in-an-array,Kth Largest Element in an Array,"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>largest element in the array</em>.</p>

<p>Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p>

<p>Can you solve it without sorting?</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [3,2,1,5,6,4], k = 2
<strong>Output:</strong> 5
</pre><p><strong class=""example"">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [3,2,3,1,2,4,5,5,6], k = 4
<strong>Output:</strong> 4
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
",Medium,"func findKthLargest(nums []int, k int) int {
    
}","
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -&gt; int:
        heap = []
        
        for n in nums:
            heapq.heappush(heap, n)
            if len(heap) &gt; k:
                heapq.heappop(heap)
        
        return heap[0]

",array divide-and-conquer sorting heap-priority-queue quickselect
872,leaf-similar-trees,Leaf-Similar Trees,"<p>Consider all the leaves of a binary tree, from&nbsp;left to right order, the values of those&nbsp;leaves form a <strong>leaf value sequence</strong><em>.</em></p>

<p><img alt="""" src=""https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png"" style=""width: 400px; height: 336px;"" /></p>

<p>For example, in the given tree above, the leaf value sequence is <code>(6, 7, 4, 9, 8)</code>.</p>

<p>Two binary trees are considered <em>leaf-similar</em>&nbsp;if their leaf value sequence is the same.</p>

<p>Return <code>true</code> if and only if the two given trees with head nodes <code>root1</code> and <code>root2</code> are leaf-similar.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg"" style=""width: 600px; height: 237px;"" />
<pre>
<strong>Input:</strong> root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
<strong>Output:</strong> true
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg"" style=""width: 300px; height: 110px;"" />
<pre>
<strong>Input:</strong> root1 = [1,2,3], root2 = [1,3,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in each tree will be in the range <code>[1, 200]</code>.</li>
	<li>Both of the given trees will have values in the range <code>[0, 200]</code>.</li>
</ul>
",Easy,"/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func leafSimilar(root1 *TreeNode, root2 *TreeNode) bool {
    
}","
class Solution:
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; bool:
        result = []
        def recur(root):
            if not root:
                return
            if not root.right and not root.left:
                result.append(root.val)
                return
            recur(root.left)
            recur(root.right)
            return
        recur(root1)
        recur(root2)
        return result[:len(result)//2] == result[len(result)//2:]

",tree depth-first-search binary-tree
17,letter-combinations-of-a-phone-number,Letter Combinations of a Phone Number,"<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>

<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png"" style=""width: 300px; height: 243px;"" />
<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> digits = &quot;23&quot;
<strong>Output:</strong> [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> digits = &quot;&quot;
<strong>Output:</strong> []
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> digits = &quot;2&quot;
<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= digits.length &lt;= 4</code></li>
	<li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li>
</ul>
",Medium,"func letterCombinations(digits string) []string {
    
}","
class Solution:
    def letterCombinations(self, digits: str) -&gt; List[str]:
        m = {2:&#34;abc&#34;,3:&#34;def&#34;,4:&#34;ghi&#34;,5:&#34;jkl&#34;, 6:&#34;mno&#34;,7:&#34;pqrs&#34;,8:&#34;tuv&#34;,9:&#34;wxyz&#34;}
        result = []
        def go(i, sofar):
            if i == len(digits):
                if sofar:
                    result.append(sofar)
                return
            
            for c in m[int(digits[i])]:
                go(i+1, sofar+c)
        go(0, &#34;&#34;)
        return result


            
",hash-table string backtracking
141,linked-list-cycle,Linked List Cycle,"<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>

<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;<code>next</code>&nbsp;pointer. Internally, <code>pos</code>&nbsp;is used to denote the index of the node that&nbsp;tail&#39;s&nbsp;<code>next</code>&nbsp;pointer is connected to.&nbsp;<strong>Note that&nbsp;<code>pos</code>&nbsp;is not passed as a parameter</strong>.</p>

<p>Return&nbsp;<code>true</code><em> if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png"" style=""width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;"" />
<pre>
<strong>Input:</strong> head = [3,2,0,-4], pos = 1
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png"" style=""width: 141px; height: 74px;"" />
<pre>
<strong>Input:</strong> head = [1,2], pos = 0
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.
</pre>

<p><strong class=""example"">Example 3:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png"" style=""width: 45px; height: 45px;"" />
<pre>
<strong>Input:</strong> head = [1], pos = -1
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no cycle in the linked list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>
",Easy,"/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
    
}","

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast=fast.next.next
            if slow == fast:
                return True
        return False
",hash-table linked-list two-pointers
1218,longest-arithmetic-subsequence-of-given-difference,Longest Arithmetic Subsequence of Given Difference,"<p>Given an integer array <code>arr</code> and an integer <code>difference</code>, return the length of the longest subsequence in <code>arr</code> which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals <code>difference</code>.</p>

<p>A <strong>subsequence</strong> is a sequence that can be derived from <code>arr</code> by deleting some or no elements without changing the order of the remaining elements.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,4], difference = 1
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest arithmetic subsequence is [1,2,3,4].</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,3,5,7], difference = 1
<strong>Output:</strong> 1
<strong>Explanation: </strong>The longest arithmetic subsequence is any single element.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,5,7,8,5,3,4,2,1], difference = -2
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest arithmetic subsequence is [7,5,3,1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= arr[i], difference &lt;= 10<sup>4</sup></code></li>
</ul>
",Medium,"func longestSubsequence(arr []int, difference int) int {
    
}","
class Solution:
    def longestSubsequence(self, arr: List[int], difference: int) -&gt; int:
        m = {}
        maxi = 1
        for n in arr:
            if n - difference in m:
                m[n] = 1 + m[n-difference]
                maxi = max(maxi, m[n])
            else:
                m[n] = 1
        return maxi




",array hash-table dynamic-programming
14,longest-common-prefix,Longest Common Prefix,"<p>Write a function to find the longest common prefix string amongst an array of strings.</p>

<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
<strong>Output:</strong> &quot;fl&quot;
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> There is no common prefix among the input strings.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= strs.length &lt;= 200</code></li>
	<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
	<li><code>strs[i]</code> consists of only lowercase English letters.</li>
</ul>
",Easy,"func longestCommonPrefix(strs []string) string {
    
}","
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -&gt; str:
        cur = 0
        while True:
            for s in strs:
                if cur &gt;= len(s) or s[cur] != strs[0][cur]:
                    return strs[0][:cur]
            cur += 1
",string trie
128,longest-consecutive-sequence,Longest Consecutive Sequence,"<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>

<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [100,4,200,1,3,2]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,3,7,2,5,8,4,6,0,1]
<strong>Output:</strong> 9
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",Medium,"func longestConsecutive(nums []int) int {
    
}","
class Solution:
    def longestConsecutive(self, nums: List[int]) -&gt; int:
        nums = list(set(nums))
        print(nums)
        arr = [n for n in range(len(nums))]
        m = {}
        val_to_index = {}
        for i, n in enumerate(nums):
            val_to_index[n] = i
        maxi = 0
        def union(a, b):
            if arr[a] == a:
                arr[b] = a
                return a
            arr[a] = union(arr[a], b)
            return arr[a]
        for i, n in enumerate(nums):
            if n + 1 in m and n - 1 in m:
                r = union(val_to_index[n+1], i)
                l = union(val_to_index[n-1], val_to_index[n+1])
                m[nums[l]] += m[nums[r]] + 1
                # if n == -1:
                #     print(m[nums[l]])
                m[n] = m[nums[l]]
                maxi = max(maxi, m[nums[l]])
            elif n + 1 in m:
                r = union(val_to_index[n+1], i)
                m[nums[r]] += 1
                m[n] = m[nums[r]]
                maxi = max(maxi, m[nums[r]])
            elif n - 1 in m:
                l = union(val_to_index[n-1], i)
                m[nums[l]] += 1
                m[n] = m[nums[l]]
                maxi = max(maxi, m[nums[l]])
            else:
                m[n] = 1
                maxi = max(maxi,1)
        # print(m)
        # print(sorted(nums))
        # print(arr)
        return maxi
",array hash-table union-find
300,longest-increasing-subsequence,Longest Increasing Subsequence,"<p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>strictly increasing </strong></em><span data-keyword=""subsequence-array""><em><strong>subsequence</strong></em></span>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,9,2,5,3,7,101,18]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,0,3,2,3]
<strong>Output:</strong> 4
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,7,7,7,7,7,7]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><b>Follow up:</b>&nbsp;Can you come up with an algorithm that runs in&nbsp;<code>O(n log(n))</code> time complexity?</p>
",Medium,"func lengthOfLIS(nums []int) int {
    
}","
class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:

        li = []

        for num in nums:
            i = bisect_left(li, num)
            if i == len(li):
                li.append(num)
            else:
                li[i] = num

        return len(li)
",array binary-search dynamic-programming
5,longest-palindromic-substring,Longest Palindromic Substring,"<p>Given a string <code>s</code>, return <em>the longest</em> <span data-keyword=""palindromic-string""><em>palindromic</em></span> <span data-keyword=""substring-nonempty""><em>substring</em></span> in <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;babad&quot;
<strong>Output:</strong> &quot;bab&quot;
<strong>Explanation:</strong> &quot;aba&quot; is also a valid answer.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cbbd&quot;
<strong>Output:</strong> &quot;bb&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> consist of only digits and English letters.</li>
</ul>
",Medium,"func longestPalindrome(s string) string {
    
}","
class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        dp = [[0]*len(s) for _ in range(len(s))]

        def get(l, r):
            print(l, r)
            result = &#34;&#34;
            while l &gt;=0 and r &lt; len(s) and s[l]==s[r]:
                result = s[l:r+1]
                l, r = l-1, r+1
            return result
        res = &#34;&#34;
        for i in range(len(s)):
            s1, s2 = get(i, i), get(i, i+1)
            ns = s1 if len(s1) &gt; len(s2) else s2
            res = ns if len(ns) &gt; len(res) else res

        return res
            
                
        



",string dynamic-programming
3,longest-substring-without-repeating-characters,Longest Substring Without Repeating Characters,"<p>Given a string <code>s</code>, find the length of the <strong>longest</strong> <span data-keyword=""substring-nonempty""><strong>substring</strong></span> without repeating characters.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcabcbb&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is &quot;abc&quot;, with the length of 3.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bbbbb&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The answer is &quot;b&quot;, with the length of 1.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;pwwkew&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is &quot;wke&quot;, with the length of 3.
Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>
</ul>
",Medium,"func lengthOfLongestSubstring(s string) int {
    
}","
class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        result = 0
        l = 0
        dict = set()
        for r in range(len(s)):
            if s[r] in dict:
                while l &lt; r:
                    if s[l] == s[r]:
                        l += 1
                        break
                    dict.remove(s[l])
                    l += 1
            dict.add(s[r])
            result = max(result, r - l + 1)
        return result
            


        
",hash-table string sliding-window
146,lru-cache,LRU Cache,"<p>Design a data structure that follows the constraints of a <strong><a href=""https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU"" target=""_blank"">Least Recently Used (LRU) cache</a></strong>.</p>

<p>Implement the <code>LRUCache</code> class:</p>

<ul>
	<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>
	<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>
	<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>
</ul>

<p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
<strong>Output</strong>
[null, null, null, 1, null, -1, null, -1, 3, 4]

<strong>Explanation</strong>
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= capacity &lt;= 3000</code></li>
	<li><code>0 &lt;= key &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>
	<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>get</code> and <code>put</code>.</li>
</ul>
",Medium,"type LRUCache struct {
    
}


func Constructor(capacity int) LRUCache {
    
}


func (this *LRUCache) Get(key int) int {
    
}


func (this *LRUCache) Put(key int, value int)  {
    
}


/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */","
class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.hashmap = {}
        # Initialize dummy nodes
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        # Set up the double linked list.
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -&gt; int:
        if key in self.hashmap:
            node = self.hashmap[key]
            self._remove(node)
            self._add(node)
            return node.value
        else:
            return -1

    def put(self, key: int, value: int) -&gt; None:
        if key in self.hashmap:
            self._remove(self.hashmap[key])
        node = Node(key, value)
        self._add(node)
        self.hashmap[key] = node
        if len(self.hashmap) &gt; self.capacity:
            node = self.head.next
            self._remove(node)
            del self.hashmap[node.key]

    def _remove(self, node):
        p = node.prev
        n = node.next
        p.next = n
        n.prev = p

    def _add(self, node):
        p = self.tail.prev
        p.next = node
        self.tail.prev = node
        node.prev = p
        node.next = self.tail

",hash-table linked-list design doubly-linked-list
1187,make-array-strictly-increasing,Make Array Strictly Increasing,"<p>Given two integer arrays&nbsp;<code>arr1</code> and <code>arr2</code>, return the minimum number of operations (possibly zero) needed&nbsp;to make <code>arr1</code> strictly increasing.</p>

<p>In one operation, you can choose two indices&nbsp;<code>0 &lt;=&nbsp;i &lt; arr1.length</code>&nbsp;and&nbsp;<code>0 &lt;= j &lt; arr2.length</code>&nbsp;and do the assignment&nbsp;<code>arr1[i] = arr2[j]</code>.</p>

<p>If there is no way to make&nbsp;<code>arr1</code>&nbsp;strictly increasing,&nbsp;return&nbsp;<code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Replace <code>5</code> with <code>2</code>, then <code>arr1 = [1, 2, 3, 6, 7]</code>.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,5,3,6,7], arr2 = [4,3,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Replace <code>5</code> with <code>3</code> and then replace <code>3</code> with <code>4</code>. <code>arr1 = [1, 3, 4, 6, 7]</code>.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> You can&#39;t make <code>arr1</code> strictly increasing.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr1.length, arr2.length &lt;= 2000</code></li>
	<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 10^9</code></li>
</ul>

<p>&nbsp;</p>
",Hard,"func makeArrayIncreasing(arr1 []int, arr2 []int) int {
    
}","
class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -&gt; int:
        arr2.sort()
        memo = {}
        inf = float(&#39;inf&#39;)
        def make(i, prev):
            if i &gt;= len(arr1):
                return 0
            
            if (i, prev) in memo:
                return memo[(i, prev)]
            
            change = inf
            
            if arr1[i] &gt; prev:
                change = min(change, make(i+1, arr1[i]))
            
            nextLarge = bisect.bisect_right(arr2, prev)
            if nextLarge != len(arr2):
                change = min(change, 1 + make(i+1, arr2[nextLarge]))
            
            memo[(i, prev)] = change
            return change
        
        res = make(0, -1)
        return res if res != inf else -1





        
",array binary-search dynamic-programming sorting
2815,max-pair-sum-in-an-array,Max Pair Sum in an Array,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. You have to find the <strong>maximum</strong> sum of a pair of numbers from <code>nums</code> such that the maximum <strong>digit </strong>in both numbers are equal.</p>

<p>Return <em>the maximum sum or</em> <code>-1</code><em> if no such pair exists</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [51,71,17,24,42]
<strong>Output:</strong> 88
<strong>Explanation:</strong> 
For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. 
For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.
It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> -1
<strong>Explanation:</strong> No pair exists in nums with equal maximum digits.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
",Easy,"func maxSum(nums []int) int {
    
}","
class Solution:
    def maxSum(self, nums: List[int]) -&gt; int:
        maxi = -1
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                s1 = str(nums[i])
                s2 = str(nums[j])
                m1 = -1
                m2 = -1
                for c in s1:
                    m1 = max(m1, int(c))
                for c in s2:
                    m2 = max(m2, int(c))
                if m1 == m2:
                    maxi = max(maxi, nums[i]+nums[j])
                    
        return maxi
                
                
        
        
",array hash-table
1615,maximal-network-rank,Maximal Network Rank,"<p>There is an infrastructure of <code>n</code> cities with some number of <code>roads</code> connecting these cities. Each <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is a bidirectional road between cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>The <strong>network rank</strong><em> </em>of <strong>two different cities</strong> is defined as the total number of&nbsp;<strong>directly</strong> connected roads to <strong>either</strong> city. If a road is directly connected to both cities, it is only counted <strong>once</strong>.</p>

<p>The <strong>maximal network rank </strong>of the infrastructure is the <strong>maximum network rank</strong> of all pairs of different cities.</p>

<p>Given the integer <code>n</code> and the array <code>roads</code>, return <em>the <strong>maximal network rank</strong> of the entire infrastructure</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<p><strong><img alt="""" src=""https://assets.leetcode.com/uploads/2020/09/21/ex1.png"" style=""width: 292px; height: 172px;"" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<p><strong><img alt="""" src=""https://assets.leetcode.com/uploads/2020/09/21/ex2.png"" style=""width: 292px; height: 172px;"" /></strong></p>

<pre>
<strong>Input:</strong> n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> There are 5 roads that are connected to cities 1 or 2.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>roads[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt;= n-1</code></li>
	<li><code>a<sub>i</sub>&nbsp;!=&nbsp;b<sub>i</sub></code></li>
	<li>Each&nbsp;pair of cities has <strong>at most one</strong> road connecting them.</li>
</ul>
",Medium,"func maximalNetworkRank(n int, roads [][]int) int {
    
}","
class Solution:
    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -&gt; int:
        adj_graph = [[0]*n for _ in range(n)]

        for a, b in roads:
            adj_graph[a][b] = 1
            adj_graph[b][a] = 1
        
        rank = [0]*n
        for i in range(n):
            rank[i] = sum(adj_graph[i])
        maxi = 0
        for i in range(n):
            for j in range(i+1, n):
                addi = adj_graph[i][j]
                maxi = max(maxi, rank[i]+rank[j]-addi)
        return maxi
        



",graph
2024,maximize-the-confusion-of-an-exam,Maximize the Confusion of an Exam,"<p>A teacher is writing a test with <code>n</code> true/false questions, with <code>&#39;T&#39;</code> denoting true and <code>&#39;F&#39;</code> denoting false. He wants to confuse the students by <strong>maximizing</strong> the number of <strong>consecutive</strong> questions with the <strong>same</strong> answer (multiple trues or multiple falses in a row).</p>

<p>You are given a string <code>answerKey</code>, where <code>answerKey[i]</code> is the original answer to the <code>i<sup>th</sup></code> question. In addition, you are given an integer <code>k</code>, the maximum number of times you may perform the following operation:</p>

<ul>
	<li>Change the answer key for any question to <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code> (i.e., set <code>answerKey[i]</code> to <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code>).</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of consecutive</em> <code>&#39;T&#39;</code>s or <code>&#39;F&#39;</code>s <em>in the answer key after performing the operation at most</em> <code>k</code> <em>times</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> answerKey = &quot;TTFF&quot;, k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> We can replace both the &#39;F&#39;s with &#39;T&#39;s to make answerKey = &quot;<u>TTTT</u>&quot;.
There are four consecutive &#39;T&#39;s.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> answerKey = &quot;TFFT&quot;, k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can replace the first &#39;T&#39; with an &#39;F&#39; to make answerKey = &quot;<u>FFF</u>T&quot;.
Alternatively, we can replace the second &#39;T&#39; with an &#39;F&#39; to make answerKey = &quot;T<u>FFF</u>&quot;.
In both cases, there are three consecutive &#39;F&#39;s.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> answerKey = &quot;TTFTTFTT&quot;, k = 1
<strong>Output:</strong> 5
<strong>Explanation:</strong> We can replace the first &#39;F&#39; to make answerKey = &quot;<u>TTTTT</u>FTT&quot;
Alternatively, we can replace the second &#39;F&#39; to make answerKey = &quot;TTF<u>TTTTT</u>&quot;. 
In both cases, there are five consecutive &#39;T&#39;s.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == answerKey.length</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>answerKey[i]</code> is either <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
",Medium,"func maxConsecutiveAnswers(answerKey string, k int) int {
    
}","
class Solution:
    def maxConsecutiveAnswers(self, answerKey: str, k: int) -&gt; int:
        t_count = 0
        l = 0
        res = 0
        for r in range(len(answerKey)):
            if answerKey[r] == &#39;T&#39;:
                t_count += 1
            while t_count &gt; k:
                if answerKey[l] == &#39;T&#39;:
                    t_count -= 1
                l += 1
            res = max(r-l+1, res)
        t_count = 0
        l = 0
        for r in range(len(answerKey)):
            if answerKey[r] == &#39;F&#39;:
                t_count += 1
            while t_count &gt; k:
                if answerKey[l] == &#39;F&#39;:
                    t_count -= 1
                l += 1
            res = max(r-l+1, res)

        return res





",string binary-search sliding-window prefix-sum
104,maximum-depth-of-binary-tree,Maximum Depth of Binary Tree,"<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>

<p>A binary tree&#39;s <strong>maximum depth</strong>&nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg"" style=""width: 400px; height: 277px;"" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 3
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1,null,2]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
",Easy,"/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxDepth(root *TreeNode) int {
    
}","
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:
        if not root:
            return 0
        return 1+max(self.maxDepth(root.left), self.maxDepth(root.right))
",tree depth-first-search breadth-first-search binary-tree
1601,maximum-number-of-achievable-transfer-requests,Maximum Number of Achievable Transfer Requests,"<p>We have <code>n</code> buildings numbered from <code>0</code> to <code>n - 1</code>. Each building has a number of employees. It&#39;s transfer season, and some employees want to change the building they reside in.</p>

<p>You are given an array <code>requests</code> where <code>requests[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> represents an employee&#39;s request to transfer from building <code>from<sub>i</sub></code> to building <code>to<sub>i</sub></code>.</p>

<p><strong>All buildings are full</strong>, so a list of requests is achievable only if for each building, the <strong>net change in employee transfers is zero</strong>. This means the number of employees <strong>leaving</strong> is <strong>equal</strong> to the number of employees <strong>moving in</strong>. For example if <code>n = 3</code> and two employees are leaving building <code>0</code>, one is leaving building <code>1</code>, and one is leaving building <code>2</code>, there should be two employees moving to building <code>0</code>, one employee moving to building <code>1</code>, and one employee moving to building <code>2</code>.</p>

<p>Return <em>the maximum number of achievable requests</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/09/10/move1.jpg"" style=""width: 600px; height: 406px;"" />
<pre>
<strong>Input:</strong> n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
<strong>Output:</strong> 5
<strong>Explantion:</strong> Let&#39;s see the requests:
From building 0 we have employees x and y and both want to move to building 1.
From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.
From building 2 we have employee z and they want to move to building 0.
From building 3 we have employee c and they want to move to building 4.
From building 4 we don&#39;t have any requests.
We can achieve the requests of users x and b by swapping their places.
We can achieve the requests of users y, a and z by swapping the places in the 3 buildings.
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/09/10/move2.jpg"" style=""width: 450px; height: 327px;"" />
<pre>
<strong>Input:</strong> n = 3, requests = [[0,0],[1,2],[2,1]]
<strong>Output:</strong> 3
<strong>Explantion:</strong> Let&#39;s see the requests:
From building 0 we have employee x and they want to stay in the same building 0.
From building 1 we have employee y and they want to move to building 2.
From building 2 we have employee z and they want to move to building 1.
We can achieve all the requests. </pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 20</code></li>
	<li><code>1 &lt;= requests.length &lt;= 16</code></li>
	<li><code>requests[i].length == 2</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>
</ul>
",Hard,"func maximumRequests(n int, requests [][]int) int {
    
}","
class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -&gt; int:
        employees = [0] * n

        def go(i, sofar):
            if len(requests) - i &lt; max(map(abs, employees)):
                return -1
            if len(requests) == i:
                return sofar
            res = 0
            res = max(res, go(i+1, sofar))
            source, dest = requests[i][0], requests[i][1]
            employees[source] -= 1
            employees[dest] += 1
            res = max(res, go(i+1, sofar+1))
            employees[source] += 1
            employees[dest] -= 1
            return res
        
        return go(0, 0)

            
            
                    
",array backtracking bit-manipulation enumeration
53,maximum-subarray,Maximum Subarray,"<p>Given an integer array <code>nums</code>, find the <span data-keyword=""subarray-nonempty"">subarray</span> with the largest sum, and return <em>its sum</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The subarray [4,-1,2,1] has the largest sum 6.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The subarray [1] has the largest sum 1.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,4,-1,7,8]
<strong>Output:</strong> 23
<strong>Explanation:</strong> The subarray [5,4,-1,7,8] has the largest sum 23.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p>
",Medium,"func maxSubArray(nums []int) int {
    
}","
class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:

        rolling =  nums[0]
        maxi = rolling
        rolling = max(nums[0], 0)
        for n in nums[1:]:
            rolling += n
            maxi = max(maxi, rolling)
            if rolling &lt; 0:
                rolling = 0
            
        return maxi


",array divide-and-conquer dynamic-programming
253,meeting-rooms-ii,Meeting Rooms II,,Medium,,"
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -&gt; int:

        heap = []
        intervals.sort()
        heap.append(intervals[0][1])
        for start, end in intervals[1:]:
            if heap[0] &lt;= start:
                heapq.heappop(heap)
            heapq.heappush(heap, end)
        return len(heap)
            
",array two-pointers greedy sorting heap-priority-queue prefix-sum
56,merge-intervals,Merge Intervals,"<p>Given an array&nbsp;of <code>intervals</code>&nbsp;where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,3],[2,6],[8,10],[15,18]]
<strong>Output:</strong> [[1,6],[8,10],[15,18]]
<strong>Explanation:</strong> Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,4],[4,5]]
<strong>Output:</strong> [[1,5]]
<strong>Explanation:</strong> Intervals [1,4] and [4,5] are considered overlapping.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>
	<li><code>intervals[i].length == 2</code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
</ul>
",Medium,"func merge(intervals [][]int) [][]int {
    
}","
class Solution:
    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:
        intervals.sort()
        result = [intervals[0]]
        for start, end in intervals[1:]:
            if start &lt;= result[-1][1]:
                result[-1][1] = max(result[-1][1], end)
            else:
                result.append([start, end])
        return result
            

",array sorting
21,merge-two-sorted-lists,Merge Two Sorted Lists,"<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>

<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>

<p>Return <em>the head of the merged linked list</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg"" style=""width: 662px; height: 302px;"" />
<pre>
<strong>Input:</strong> list1 = [1,2,4], list2 = [1,3,4]
<strong>Output:</strong> [1,1,2,3,4,4]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> list1 = [], list2 = []
<strong>Output:</strong> []
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> list1 = [], list2 = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li>
</ul>
",Easy,"/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    
}","
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:
        result = ListNode(0)
        dummy = result
        while list1 and list2:
            if list1.val &lt; list2.val:
                dummy.next = list1
                list1 = list1.next
            else:
                dummy.next = list2
                list2 = list2.next
            dummy = dummy.next
        dummy.next = list1 if list1 else list2
        return result.next

",linked-list recursion
155,min-stack,Min Stack,"<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>

<p>Implement the <code>MinStack</code> class:</p>

<ul>
	<li><code>MinStack()</code> initializes the stack object.</li>
	<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>
	<li><code>void pop()</code> removes the element on the top of the stack.</li>
	<li><code>int top()</code> gets the top element of the stack.</li>
	<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>
</ul>

<p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]

<strong>Output</strong>
[null,null,null,null,-3,null,0,-2]

<strong>Explanation</strong>
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>
	<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>
	<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li>
</ul>
",Medium,"type MinStack struct {
    
}


func Constructor() MinStack {
    
}


func (this *MinStack) Push(val int)  {
    
}


func (this *MinStack) Pop()  {
    
}


func (this *MinStack) Top() int {
    
}


func (this *MinStack) GetMin() int {
    
}


/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(val);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.GetMin();
 */","
class MinStack:

    def __init__(self):
        self.stack = []
        
    def push(self, val: int) -&gt; None:
        if self.stack:
            self.stack.append((val, min(val, self.stack[-1][1])))
        else:
            self.stack.append((val, val))
        

    def pop(self) -&gt; None:
        self.stack.pop()
        

    def top(self) -&gt; int:
        return self.stack[-1][0]
        

    def getMin(self) -&gt; int:
        return self.stack[-1][1]


        


",stack design
2616,minimize-the-maximum-difference-of-pairs,Minimize the Maximum Difference of Pairs,"<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>p</code>. Find <code>p</code> pairs of indices of <code>nums</code> such that the <strong>maximum</strong> difference amongst all the pairs is <strong>minimized</strong>. Also, ensure no index appears more than once amongst the <code>p</code> pairs.</p>

<p>Note that for a pair of elements at the index <code>i</code> and <code>j</code>, the difference of this pair is <code>|nums[i] - nums[j]|</code>, where <code>|x|</code> represents the <strong>absolute</strong> <strong>value</strong> of <code>x</code>.</p>

<p>Return <em>the <strong>minimum</strong> <strong>maximum</strong> difference among all </em><code>p</code> <em>pairs.</em> We define the maximum of an empty set to be zero.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,1,2,7,1,3], p = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. 
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,2,1,2], p = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= p &lt;= (nums.length)/2</code></li>
</ul>
",Medium,"func minimizeMax(nums []int, p int) int {
    
}","
class Solution:
    def minimizeMax(self, nums: List[int], p: int) -&gt; int:
        nums.sort()
        l, r = 0, nums[-1] - nums[0]
        while l &lt;= r:
            mid = l + (r-l) // 2
            i, cnt = 0, 0
            while i &lt; len(nums) -1:
                if nums[i+1] - nums[i] &lt;= mid:
                    cnt += 1
                    i += 1
                i += 1
            if cnt &lt; p:
                l = mid + 1
            else:
                r = mid - 1

        return l



            


",array binary-search greedy
111,minimum-depth-of-binary-tree,Minimum Depth of Binary Tree,"<p>Given a binary tree, find its minimum depth.</p>

<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>

<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg"" style=""width: 432px; height: 302px;"" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 2
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [2,null,3,null,4,null,5,null,6]
<strong>Output:</strong> 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>5</sup>]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
",Easy,"/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func minDepth(root *TreeNode) int {
    
}","
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -&gt; int:
        def recur(cur):
            if not cur.left and not cur.right:
                return 1
            mini = float(&#39;inf&#39;)
            if cur.left:
                mini = min(mini, 1+recur(cur.left))
            if cur.right:
                mini = min(mini, 1+recur(cur.right))
            return mini
        return recur(root) if root else 0


            
        
",tree depth-first-search breadth-first-search binary-tree
452,minimum-number-of-arrows-to-burst-balloons,Minimum Number of Arrows to Burst Balloons,"<p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [x<sub>start</sub>, x<sub>end</sub>]</code> denotes a balloon whose <strong>horizontal diameter</strong> stretches between <code>x<sub>start</sub></code> and <code>x<sub>end</sub></code>. You do not know the exact y-coordinates of the balloons.</p>

<p>Arrows can be shot up <strong>directly vertically</strong> (in the positive y-direction) from different points along the x-axis. A balloon with <code>x<sub>start</sub></code> and <code>x<sub>end</sub></code> is <strong>burst</strong> by an arrow shot at <code>x</code> if <code>x<sub>start</sub> &lt;= x &lt;= x<sub>end</sub></code>. There is <strong>no limit</strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p>

<p>Given the array <code>points</code>, return <em>the <strong>minimum</strong> number of arrows that must be shot to burst all balloons</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> points = [[10,16],[2,8],[1,6],[7,12]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> points = [[1,2],[3,4],[5,6],[7,8]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One arrow needs to be shot for each balloon for a total of 4 arrows.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> points = [[1,2],[2,3],[3,4],[4,5]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= points.length &lt;= 10<sup>5</sup></code></li>
	<li><code>points[i].length == 2</code></li>
	<li><code>-2<sup>31</sup> &lt;= x<sub>start</sub> &lt; x<sub>end</sub> &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
",Medium,"func findMinArrowShots(points [][]int) int {
    
}","
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        points.sort()
        overlap1 = points[0][1]
        result = 0
        for i in range(1, len(points)):
            if points[i][0] &gt; overlap1:
                result += 1
                overlap1 = points[i][1]
            else:
                overlap1 = min(overlap1,  points[i][1])
        return result + 1

            
            
",array greedy sorting
1443,minimum-time-to-collect-all-apples-in-a-tree,Minimum Time to Collect All Apples in a Tree,"<p>Given an undirected tree consisting of <code>n</code> vertices numbered from <code>0</code> to <code>n-1</code>, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. <em>Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at <strong>vertex 0</strong> and coming back to this vertex.</em></p>

<p>The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means that exists an edge connecting the vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Additionally, there is a boolean array <code>hasApple</code>, where <code>hasApple[i] = true</code> means that vertex <code>i</code> has an apple; otherwise, it does not have any apple.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_1.png"" style=""width: 300px; height: 212px;"" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
<strong>Output:</strong> 8 
<strong>Explanation:</strong> The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_2.png"" style=""width: 300px; height: 212px;"" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>hasApple.length == n</code></li>
</ul>
",Medium,"func minTime(n int, edges [][]int, hasApple []bool) int {
    
}","
class Solution:
    def minTime(self, n: int, edge_list: List[List[int]], hasApple: List[bool]) -&gt; int:
        edges = set()
        visited = {0}
        adj_list = collections.defaultdict(list)
        for start, end in edge_list:
            adj_list[start].append(end)
            adj_list[end].append(start)
        def dfs(cur, path):
            if hasApple[cur]:
                for p in path:
                    edges.add(p)
            for n in adj_list[cur]:
                if n not in visited:
                    visited.add(n)
                    dfs(n, path+[(cur, n)])
            return
        dfs(0, [])
        return 2*len(edges)
        





",hash-table tree depth-first-search breadth-first-search
76,minimum-window-substring,Minimum Window Substring,"<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <span data-keyword=""substring-nonempty""><strong><em>substring</em></strong></span><em> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>&quot;&quot;</code>.</p>

<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;
<strong>Output:</strong> &quot;BANC&quot;
<strong>Explanation:</strong> The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;a&quot;, t = &quot;a&quot;
<strong>Output:</strong> &quot;a&quot;
<strong>Explanation:</strong> The entire string s is the minimum window.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot;
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> Both &#39;a&#39;s from t must be included in the window.
Since the largest window of s only has one &#39;a&#39;, return empty string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == s.length</code></li>
	<li><code>n == t.length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</p>
",Hard,"func minWindow(s string, t string) string {
    
}","
class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        c = collections.Counter(t)
        cur = collections.Counter()
        
        best = len(s)+1
        start = -1
        left = 0
        
        for r in range(len(s)):
            cur[s[r]] += 1
            
            while cur &gt;= c:
                if r - left + 1 &lt; best:
                    best = r - left + 1
                    start = left
                cur[s[left]]-=1
                left+=1
    
        return s[start:start+best] if start != -1 else &#34;&#34;
",hash-table string sliding-window
435,non-overlapping-intervals,Non-overlapping Intervals,"<p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,2],[2,3],[3,4],[1,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> [1,3] can be removed and the rest of the intervals are non-overlapping.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,2],[1,2],[1,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> You need to remove two [1,2] to make the rest of the intervals non-overlapping.
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,2],[2,3]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>
	<li><code>intervals[i].length == 2</code></li>
	<li><code>-5 * 10<sup>4</sup> &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 5 * 10<sup>4</sup></code></li>
</ul>
",Medium,"func eraseOverlapIntervals(intervals [][]int) int {
    
}","
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:
        intervals.sort()
        prev_end = intervals[0][1]
        result = 0
        for start, end in intervals[1:]:
            if start &lt; prev_end:
                prev_end = min(prev_end, end)
                result += 1
            else:
                prev_end = end
        return result




",array dynamic-programming greedy sorting
200,number-of-islands,Number of Islands,"<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>

<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
]
<strong>Output:</strong> 1
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]
]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
",Medium,"func numIslands(grid [][]byte) int {
    
}","
class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]
        res = 0
        def dfs(i, j):
            nonlocal res
            for di, dj in [(0,1), (0,-1),(1,0),(-1,0)]:
                if 0 &lt;= i+di&lt;len(grid) and 0 &lt;= j+dj &lt; len(grid[0]) and not visited[i+di][j+dj]:
                    visited[i+di][j+dj] = True
                    if grid[i+di][j+dj] == &#39;1&#39;:
                        fill(i+di, j+dj)
                        res += 1
                    else:
                        dfs(i+di, j + dj)
        def fill(i, j):
            for di, dj in [(0,1), (0,-1),(1,0),(-1,0)]:
                if 0&lt;=i+di&lt;len(grid) and 0 &lt;= j+dj &lt; len(grid[0]) and not visited[i+di][j+dj] and grid[i+di][j+dj] == &#39;1&#39;:
                    visited[i+di][j+dj] = True
                    fill(i+di, j+dj) 
        visited[0][0] = True
        if grid[0][0] == &#39;1&#39;:
            res = 1
            fill(0, 0)
        for x in range(len(grid)):
            for y in range(len(grid[0])):
                if not visited[x][y]:
                    dfs(x, y)

        return res


            
",array depth-first-search breadth-first-search union-find matrix
2405,optimal-partition-of-string,Optimal Partition of String,"<p>Given a string <code>s</code>, partition the string into one or more <strong>substrings</strong> such that the characters in each substring are <strong>unique</strong>. That is, no letter appears in a single substring more than <strong>once</strong>.</p>

<p>Return <em>the <strong>minimum</strong> number of substrings in such a partition.</em></p>

<p>Note that each character should belong to exactly one substring in a partition.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abacaba&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong>
Two possible partitions are (&quot;a&quot;,&quot;ba&quot;,&quot;cab&quot;,&quot;a&quot;) and (&quot;ab&quot;,&quot;a&quot;,&quot;ca&quot;,&quot;ba&quot;).
It can be shown that 4 is the minimum number of substrings needed.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ssssss&quot;
<strong>Output:</strong> 6
<strong>Explanation:
</strong>The only valid partition is (&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of only English lowercase letters.</li>
</ul>
",Medium,"func partitionString(s string) int {
    
}","
class Solution:
    def partitionString(self, s: str) -&gt; int:
        se = set()
        result = []
        cur = &#34;&#34;
        for c in s:
            if c not in se:
                se.add(c)
                cur+=c
            else:
                result.append(cur)
                se = {c}
                cur = c
        return len(result)+1


",hash-table string greedy
131,palindrome-partitioning,Palindrome Partitioning,"<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=""substring-nonempty"">substring</span> of the partition is a <span data-keyword=""palindrome-string""><strong>palindrome</strong></span>. Return <em>all possible palindrome partitioning of </em><code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<pre><strong>Input:</strong> s = ""aab""
<strong>Output:</strong> [[""a"",""a"",""b""],[""aa"",""b""]]
</pre><p><strong class=""example"">Example 2:</strong></p>
<pre><strong>Input:</strong> s = ""a""
<strong>Output:</strong> [[""a""]]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 16</code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
</ul>
",Medium,"func partition(s string) [][]string {
    
}","
class Solution:
    def partition(self, s: str) -&gt; List[List[str]]:
        def check(cur):
            l, r = 0, len(cur)-1
            while l &lt;= r:
                if cur[l] != cur[r]:
                    return False
                l += 1
                r -= 1
            return True
        result = []
        def recur(index, cur):
            if index &gt; len(s):
                return
            if index == len(s):
                result.append(cur)
                return
            for i in range(index+1, len(s)+1):
                if check(s[index:i]):
                    recur(i, cur+[s[index:i]])
            return
        recur(0, [])
        return result


",string dynamic-programming backtracking
46,permutations,Permutations,"<p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre><p><strong class=""example"">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> [[0,1],[1,0]]
</pre><p><strong class=""example"">Example 3:</strong></p>
<pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> [[1]]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 6</code></li>
	<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
	<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
",Medium,"func permute(nums []int) [][]int {
    
}","
class Solution:
    def permute(self, nums: List[int]) -&gt; List[List[int]]:
        result = []
        result.append(nums)

        # def go(remain):
        #     cur = []
        #     for res in result:
        #         for i, rem in enumerate(remain):
        #             cur.append(res+[rem])
        def go(i, cur):
            if i &gt;= len(cur):
                return
            go(i+1, cur)
            for j in range(i+1, len(nums)):
                nums[i], nums[j] = nums[j], nums[i]
                result.append(nums[::])
                go(i+1, nums[::])
                nums[i], nums[j] = nums[j], nums[i]
        go(0, nums)
        return result


",array backtracking
50,powx-n,"Pow(x, n)","<p>Implement <a href=""http://www.cplusplus.com/reference/valarray/pow/"" target=""_blank"">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x<sup>n</sup></code>).</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> x = 2.00000, n = 10
<strong>Output:</strong> 1024.00000
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> x = 2.10000, n = 3
<strong>Output:</strong> 9.26100
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> x = 2.00000, n = -2
<strong>Output:</strong> 0.25000
<strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>-100.0 &lt; x &lt; 100.0</code></li>
	<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li>
	<li><code>n</code> is an integer.</li>
	<li>Either <code>x</code> is not zero or <code>n &gt; 0</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li>
</ul>
",Medium,"func myPow(x float64, n int) float64 {
    
}","
class Solution:
    def myPow(self, x: float, n: int) -&gt; float:
        return x ** n
",math recursion
238,product-of-array-except-self,Product of Array Except Self,"<p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>

<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>

<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and without using the division operation.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> [24,12,8,6]
</pre><p><strong class=""example"">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [-1,1,0,-3,3]
<strong>Output:</strong> [0,0,9,0,0]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>
	<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong>&nbsp;Can you solve the problem in <code>O(1)&nbsp;</code>extra&nbsp;space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p>
",Medium,"func productExceptSelf(nums []int) []int {
    
}","
class Solution:
    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:
        lhs, rhs = [1], [1]
        res = []
        for n in nums[:-1]:
            lhs.append(n*lhs[-1])
        for n in reversed(nums[1:]):
            rhs.append(n*rhs[-1])
        rhs.reverse()
        for i in range(len(nums)):
            res.append(lhs[i]*rhs[i])
        return res
        
        
",array prefix-sum
2551,put-marbles-in-bags,Put Marbles in Bags,"<p>You have <code>k</code> bags. You are given a <strong>0-indexed</strong> integer array <code>weights</code> where <code>weights[i]</code> is the weight of the <code>i<sup>th</sup></code> marble. You are also given the integer <code>k.</code></p>

<p>Divide the marbles into the <code>k</code> bags according to the following rules:</p>

<ul>
	<li>No bag is empty.</li>
	<li>If the <code>i<sup>th</sup></code> marble and <code>j<sup>th</sup></code> marble are in a bag, then all marbles with an index between the <code>i<sup>th</sup></code> and <code>j<sup>th</sup></code> indices should also be in that same bag.</li>
	<li>If a bag consists of all the marbles with an index from <code>i</code> to <code>j</code> inclusively, then the cost of the bag is <code>weights[i] + weights[j]</code>.</li>
</ul>

<p>The <strong>score</strong> after distributing the marbles is the sum of the costs of all the <code>k</code> bags.</p>

<p>Return <em>the <strong>difference</strong> between the <strong>maximum</strong> and <strong>minimum</strong> scores among marble distributions</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> weights = [1,3,5,1], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
The distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. 
The distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. 
Thus, we return their difference 10 - 6 = 4.
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> weights = [1, 3], k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> The only distribution possible is [1],[3]. 
Since both the maximal and minimal score are the same, we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= weights.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= weights[i] &lt;= 10<sup>9</sup></code></li>
</ul>
",Hard,"func putMarbles(weights []int, k int) int64 {
    
}","
class Solution:
    def putMarbles(self, weights: List[int], k: int) -&gt; int:
        # [9,8,9,1]
        minpq, maxpq = [], []
        for i in range(len(weights)-1):
            heapq.heappush(maxpq, -(weights[i]+weights[i+1]))
            heapq.heappush(minpq, (weights[i]+weights[i+1]))
            while len(maxpq) &gt; k-1:
                heapq.heappop(maxpq)
            while len(minpq) &gt; k-1:
                heapq.heappop(minpq)
        return sum(maxpq)+sum(minpq)
        


",array greedy sorting heap-priority-queue
383,ransom-note,Ransom Note,"<p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code><em> if </em><code>ransomNote</code><em> can be constructed by using the letters from </em><code>magazine</code><em> and </em><code>false</code><em> otherwise</em>.</p>

<p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<pre><strong>Input:</strong> ransomNote = ""a"", magazine = ""b""
<strong>Output:</strong> false
</pre><p><strong class=""example"">Example 2:</strong></p>
<pre><strong>Input:</strong> ransomNote = ""aa"", magazine = ""ab""
<strong>Output:</strong> false
</pre><p><strong class=""example"">Example 3:</strong></p>
<pre><strong>Input:</strong> ransomNote = ""aa"", magazine = ""aab""
<strong>Output:</strong> true
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10<sup>5</sup></code></li>
	<li><code>ransomNote</code> and <code>magazine</code> consist of lowercase English letters.</li>
</ul>
",Easy,"func canConstruct(ransomNote string, magazine string) bool {
    
}","
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        c = collections.Counter(magazine)
        for n in ransomNote:
            if c[n] &lt;= 0:
                return False
            c[n] -= 1
        return True
        


        
",hash-table string counting
684,redundant-connection,Redundant Connection,"<p>In this problem, a tree is an <strong>undirected graph</strong> that is connected and has no cycles.</p>

<p>You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The added edge has two <strong>different</strong> vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed. The graph is represented as an array <code>edges</code> of length <code>n</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the graph.</p>

<p>Return <em>an edge that can be removed so that the resulting graph is a tree of </em><code>n</code><em> nodes</em>. If there are multiple answers, return the answer that occurs last in the input.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg"" style=""width: 222px; height: 222px;"" />
<pre>
<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> [2,3]
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg"" style=""width: 382px; height: 222px;"" />
<pre>
<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
<strong>Output:</strong> [1,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>3 &lt;= n &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= edges.length</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
	<li>The given graph is connected.</li>
</ul>
",Medium,"func findRedundantConnection(edges [][]int) []int {
    
}","
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]:
        arr = [x for x in range(len(edges)+1)]
        def find(x):
            if arr[x] == x:
                return x
            return find(arr[x])
        def union(a, b):
            arr[find(a)] = b
        for a, b in edges:
            if find(a) == find(b):
                return [a, b]        
            union(a, b)
",depth-first-search breadth-first-search union-find graph
27,remove-element,Remove Element,"<p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href=""https://en.wikipedia.org/wiki/In-place_algorithm"" target=""_blank""><strong>in-place</strong></a>. The order of the elements may be changed. Then return <em>the number of elements in </em><code>nums</code><em> which are not equal to </em><code>val</code>.</p>

<p>Consider the number of elements in <code>nums</code> which are not equal to <code>val</code> be <code>k</code>, to get accepted, you need to do the following things:</p>

<ul>
	<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the elements which are not equal to <code>val</code>. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>
	<li>Return <code>k</code>.</li>
</ul>

<p><strong>Custom Judge:</strong></p>

<p>The judge will test your solution with the following code:</p>

<pre>
int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i &lt; actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
</pre>

<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,2,3], val = 3
<strong>Output:</strong> 2, nums = [2,2,_,_]
<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,2,2,3,0,4,2], val = 2
<strong>Output:</strong> 5, nums = [0,1,4,0,3,_,_,_]
<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
	<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
",Easy,"func removeElement(nums []int, val int) int {
    
}","
class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        l = 0
        for r in range(len(nums)):
            if nums[r] != val:
                nums[l] = nums[r]
                l += 1
        return l
    
",array two-pointers
19,remove-nth-node-from-end-of-list,Remove Nth Node From End of List,"<p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"" style=""width: 542px; height: 222px;"" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], n = 2
<strong>Output:</strong> [1,2,3,5]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [1], n = 1
<strong>Output:</strong> []
</pre>

<p><strong class=""example"">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = [1,2], n = 1
<strong>Output:</strong> [1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>sz</code>.</li>
	<li><code>1 &lt;= sz &lt;= 30</code></li>
	<li><code>0 &lt;= Node.val &lt;= 100</code></li>
	<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you do this in one pass?</p>
",Medium,"/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    
}","
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:
        dum = head
        cnt = 0
        while dum:
            dum = dum.next
            cnt += 1
        prev, cur = None, head
        cnt -= n
        while cnt &gt; 0:
            prev = cur
            cur = cur.next
            cnt -= 1
        if prev:
            prev.next = cur.next
        else:
            head = cur.next
        return head

        


",linked-list two-pointers
2390,removing-stars-from-a-string,Removing Stars From a String,"<p>You are given a string <code>s</code>, which contains stars <code>*</code>.</p>

<p>In one operation, you can:</p>

<ul>
	<li>Choose a star in <code>s</code>.</li>
	<li>Remove the closest <strong>non-star</strong> character to its <strong>left</strong>, as well as remove the star itself.</li>
</ul>

<p>Return <em>the string after <strong>all</strong> stars have been removed</em>.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>The input will be generated such that the operation is always possible.</li>
	<li>It can be shown that the resulting string will always be unique.</li>
</ul>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leet**cod*e&quot;
<strong>Output:</strong> &quot;lecoe&quot;
<strong>Explanation:</strong> Performing the removals from left to right:
- The closest character to the 1<sup>st</sup> star is &#39;t&#39; in &quot;lee<strong><u>t</u></strong>**cod*e&quot;. s becomes &quot;lee*cod*e&quot;.
- The closest character to the 2<sup>nd</sup> star is &#39;e&#39; in &quot;le<strong><u>e</u></strong>*cod*e&quot;. s becomes &quot;lecod*e&quot;.
- The closest character to the 3<sup>rd</sup> star is &#39;d&#39; in &quot;leco<strong><u>d</u></strong>*e&quot;. s becomes &quot;lecoe&quot;.
There are no more stars, so we return &quot;lecoe&quot;.</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;erase*****&quot;
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> The entire string is removed, so we return an empty string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters and stars <code>*</code>.</li>
	<li>The operation above can be performed on <code>s</code>.</li>
</ul>
",Medium,"func removeStars(s string) string {
    
}","
class Solution:
    def removeStars(self, s: str) -&gt; str:
        stack = []
        for c in s:
            if stack and c == &#39;*&#39;:
                stack.pop()
            elif c != &#39;*&#39;:
                stack.append(c)
        return &#34;&#34;.join(stack)
                

",string stack simulation
92,reverse-linked-list-ii,Reverse Linked List II,"<p>Given the <code>head</code> of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position <code>left</code> to position <code>right</code>, and return <em>the reversed list</em>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg"" style=""width: 542px; height: 222px;"" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], left = 2, right = 4
<strong>Output:</strong> [1,4,3,2,5]
</pre>

<p><strong class=""example"">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [5], left = 1, right = 1
<strong>Output:</strong> [5]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>n</code>.</li>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>-500 &lt;= Node.val &lt;= 500</code></li>
	<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you do it in one pass?",Medium,"/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    
}","
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&gt; Optional[ListNode]:
        dummy = head
        prev = None
        lleft = left
        while lleft &gt; 1:
            prev = dummy
            dummy = dummy.next
            lleft -= 1
        end = None
        def recur(index, cur_node, prev):
            if index == 1:
                nonlocal end
                end = cur_node.next
                cur_node.next = prev
                return cur_node
            save = recur(index-1, cur_node.next, cur_node)
            cur_node.next = prev
            return save
        save_head = dummy
        if prev:
            prev.next = recur(right-left+1, dummy, prev)
        else:
            head = recur(right-left+1, dummy, prev)
        save_head.next = end
        return head 



",linked-list
48,rotate-image,Rotate Image,"<p>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p>

<p>You have to rotate the image <a href=""https://en.wikipedia.org/wiki/In-place_algorithm"" target=""_blank""><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg"" style=""width: 500px; height: 188px;"" />
<pre>
<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> [[7,4,1],[8,5,2],[9,6,3]]
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg"" style=""width: 500px; height: 201px;"" />
<pre>
<strong>Input:</strong> matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
<strong>Output:</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == matrix.length == matrix[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 20</code></li>
	<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
",Medium,"func rotate(matrix [][]int)  {
    
}","
class Solution:
    def rotate(self, matrix: List[List[int]]) -&gt; None:
        &#34;&#34;&#34;
        Do not return anything, modify matrix in-place instead.
        &#34;&#34;&#34;
        C = len(matrix)
        def rotateLayer(i):
            for j in range(i, len(matrix)-i-1):
                matrix[i][j], matrix[j][C-i-1], matrix[C-i-1][C-j-1],matrix[C-j-1][i] = matrix[C-j-1][i] , matrix[i][j], matrix[j][C-i-1], matrix[C-i-1][C-j-1]  
        for n in range(C//2):
            rotateLayer(n)
        

        
",array math matrix
100,same-tree,Same Tree,"<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>

<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg"" style=""width: 622px; height: 182px;"" />
<pre>
<strong>Input:</strong> p = [1,2,3], q = [1,2,3]
<strong>Output:</strong> true
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg"" style=""width: 382px; height: 182px;"" />
<pre>
<strong>Input:</strong> p = [1,2], q = [1,null,2]
<strong>Output:</strong> false
</pre>

<p><strong class=""example"">Example 3:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg"" style=""width: 622px; height: 182px;"" />
<pre>
<strong>Input:</strong> p = [1,2,1], q = [1,1,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
",Easy,"/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSameTree(p *TreeNode, q *TreeNode) bool {
    
}","
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:
        if not p and not q:
            return True
        if not p or not q or not (p.val == q.val):
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        
        
",tree depth-first-search breadth-first-search binary-tree
74,search-a-2d-matrix,Search a 2D Matrix,"<p>You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:</p>

<ul>
	<li>Each row is sorted in non-decreasing order.</li>
	<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>

<p>Given an integer <code>target</code>, return <code>true</code> <em>if</em> <code>target</code> <em>is in</em> <code>matrix</code> <em>or</em> <code>false</code> <em>otherwise</em>.</p>

<p>You must write a solution in <code>O(log(m * n))</code> time complexity.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/05/mat.jpg"" style=""width: 322px; height: 242px;"" />
<pre>
<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
<strong>Output:</strong> true
</pre>

<p><strong class=""example"">Example 2:</strong></p>
<img alt="""" src=""https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg"" style=""width: 322px; height: 242px;"" />
<pre>
<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>
</ul>
",Medium,"func searchMatrix(matrix [][]int, target int) bool {
    
}","
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        L, W = len(matrix), len(matrix[0])
        left, right = 0, L*W-1

        while left &lt;= right:
            mid = left + (right-left) // 2
            i, j = mid // W, mid % W

            if matrix[i][j] &lt; target:
                left = mid + 1
            elif matrix[i][j] &gt; target:
                right = mid - 1
            else:
                return True

        return False

        
",array binary-search matrix
33,search-in-rotated-sorted-array,Search in Rotated Sorted Array,"<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>

<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>

<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>

<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0
<strong>Output:</strong> 4
</pre><p><strong class=""example"">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3
<strong>Output:</strong> -1
</pre><p><strong class=""example"">Example 3:</strong></p>
<pre><strong>Input:</strong> nums = [1], target = 0
<strong>Output:</strong> -1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li>All values of <code>nums</code> are <strong>unique</strong>.</li>
	<li><code>nums</code> is an ascending array that is possibly rotated.</li>
	<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>
",Medium,"func search(nums []int, target int) int {
    
}","
class Solution:
    def search(self, nums: List[int], target: int) -&gt; int:

        l, r = 0, len(nums)-1

        while l &lt;= r:
            mid = l + (r-l) // 2
            if nums[mid] &gt; nums[-1]:
                l = mid + 1
            else:
                r = mid - 1
        

        shift = l
        l, r = 0, len(nums)-1
        while l &lt;= r:
            mid = l + (r-l) // 2
            if nums[(mid+shift)%len(nums)] == target:
                return (mid+shift)%len(nums)
            elif nums[(mid+shift)%len(nums)] &gt; target:
                r = mid - 1
            else:
                l = mid + 1
        return -1
            
",array binary-search
73,set-matrix-zeroes,Set Matrix Zeroes,"<p>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>&#39;s.</p>

<p>You must do it <a href=""https://en.wikipedia.org/wiki/In-place_algorithm"" target=""_blank"">in place</a>.</p>

<p>&nbsp;</p>
<p><strong class=""example"">Example 1:</strong></p>
<